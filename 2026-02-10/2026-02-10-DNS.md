# 2026-02-10-DNS

---

## 🌐 DNS (Domain Name System) 핵심 요약

DNS는 한마디로 **"인터넷의 전화번호부"**이다. 우리가 `google.com` 같은 문자를 입력하면, 컴퓨터가 이해할 수 있는 IP 주소(`142.250.196.142`)로 변환해 주는 시스템.

### 1. 왜 필요한가요?

사람은 문자를 외우기 쉽지만, 컴퓨터는 숫자로 된 주소로 통신하기 때문이다. 수많은 웹사이트의 IP 주소를 다 외울 수 없으니 DNS가 중간에서 번역가 역할을 해준다.

### 2. DNS 작동 원리 (계층 구조)

DNS는 전 세계에 분산된 서버들이 계층적으로 연결되어 작동한다.

1. **Local DNS Server:** 통신사(SKT, KT 등)나 구글(8.8.8.8)이 운영하는 첫 번째 관문.
2. **Root DNS Server:** 최상위 서버입니다. "`.com` 담당 서버 어디야?"라고 물어봄.
3. **TLD (Top Level Domain) Server:** `.com`, `.net`, `.kr` 등 확장자별로 관리하는 서버.
4. **Authoritative DNS Server:** 최종적으로 `google.com`의 실제 IP 주소를 가지고 있는 서버.

### 3. DNS 레코드 종류

* **A 레코드:** 도메인 이름을 IPv4 주소에 매핑 (가장 기본).
* **AAAA 레코드:** 도메인 이름을 IPv6 주소에 매핑.
* **CNAME:** 도메인에 별칭(Alias)을 부여 (예: `www.test.com`을 `test.com`으로 연결).
* **MX:** 메일 서버 주소를 지정.

---

## 🛠️ 실습해 보기 (터미널 팁)

맥북 터미널에서 아래 명령어를 입력해 보세요. DNS가 실제로 어떻게 작동하는지 바로 확인할 수 있습니다.

```bash
# 특정 도메인의 IP 주소 확인
nslookup google.com

# DNS가 거쳐가는 경로를 상세히 추적
dig +trace google.com

```

DNS의 동작 원리는 단순히 "묻고 답하기" 같지만, 실제로는 여러 서버를 거치는 **재귀적 쿼리(Recursive Query)** 과정을 거친다.

---

## 🔄 DNS 검색 흐름 (Step-by-Step)

사용자가 브라우저 주소창에 `www.google.com`을 입력했을 때 벌어지는 일.

1. **브라우저 캐시 확인:** 가장 먼저 내 컴퓨터(브라우저, OS)가 해당 IP를 기억하고 있는지 확인합니다. 있으면 거기서 끝!
2. **Recursive Resolver (Local DNS)에게 요청:** 캐시에 없다면, 통신사(SK, KT 등)가 운영하는 DNS 서버에게 "야, https://www.google.com/search?q=google.com 주소 좀 찾아줘"라고 부탁합니다.
3. **Root Name Server 방문:** Local DNS는 주소를 모르면 '루트 서버'에게 물어봅니다. 루트 서버는 ".com 담당자한테 가봐"라며 **TLD 서버의 주소**를 알려줍니다.
4. **TLD Name Server (.com) 방문:** TLD 서버는 다시 "https://www.google.com/search?q=google.com 은 구글 전용 서버가 관리해"라며 **Authoritative 서버의 주소**를 알려줍니다.
5. **Authoritative Name Server 방문:** 드디어 구글의 진짜 이름 서버에 도착했습니다. 여기서 비로소 `www.google.com`의 **최종 IP 주소**를 전달합니다.
6. **결과 전달 및 캐싱:** Local DNS는 이 IP를 나에게 전달하면서, 다음에 또 물어볼 때를 대비해 자신의 메모리에 저장(Caching)해 둡니다.

---

## 📝 요약표

| 단계 | 주체 | 역할 | 비유 |
| --- | --- | --- | --- |
| **1** | **Recursive Resolver** | 해결사 | 대신 발품 팔아주는 심부름꾼 |
| **2** | **Root Server** | 안내소 | 도서관의 '대분류' 안내판 |
| **3** | **TLD Server** | 구역 담당자 | 서가의 '장르(인문, 과학 등)' 구분 |
| **4** | **Authoritative Server** | 최종 책임자 | 실제 책이 꽂혀 있는 위치 정보 |

---

## 왜 IP를 직접 안 쓰고 DNS를 쓰나요?

사실 우리가 IP를 직접 외워서 친다면 DNS 서버를 거치지 않아도 되니 더 빠를 것 같지만, 현실적으로는 불가능에 가깝고 위험하기도하다.

### ① 인간의 한계 (가독성)

가장 단순한 이유다. `142.250.196.142`를 외우는 것보다 `google.com`을 기억하는 게 훨씬 쉽다. 수천 개의 웹사이트 주소를 숫자로 외우는 건 불가능.

### ② 유연한 서버 관리 (가장 중요한 기술적 이유)

서비스의 IP 주소는 언제든 바뀔 수 있다.

* 서버를 이전하거나,
* 트래픽이 몰려 서버 대수를 늘리거나(Load Balancing),
* 보안상의 이유로 IP를 교체해야 할 때가 있습니다.

만약 우리가 IP를 직접 썼다면, 구글이 서버 주소를 바꿀 때마다 전 세계 사용자에게 "새 IP는 이거니까 여기로 접속하세요"라고 공지해야 한다. 하지만 **DNS를 쓰면 IP가 바뀌어도 도메인 이름만 그대로 유지**하면 되므로 사용자는 변화를 전혀 느끼지 못합니다.

---

## 2. 캐싱(Caching)의 중요성

DNS 서버는 전 세계에 흩어져 있고 계층 구조로 되어 있다. 매번 루트 서버부터 차례대로 물어본다면 인터넷 속도는 엄청나게 느려질 것. 그래서 **캐싱**이 필요.

### 🚀 캐싱의 효과

* **속도 향상:** 한 번 찾은 주소는 내 컴퓨터나 로컬 DNS 서버에 저장해 둔다. 다음에 접속할 때는 미국에 있는 루트 서버까지 갈 필요 없이 즉시 IP를 알아낼 수 있다.
* **트래픽 감소:** 전 세계 모든 요청이 루트 서버로 몰리는 것을 방지. 캐싱 덕분에 상위 서버들의 부하가 획기적으로 줄어든다.

### ⚠️ 주의점: TTL (Time To Live)

캐시가 만능은 아닙니다. 만약 서버 IP가 바뀌었는데 내 컴퓨터에 옛날 IP가 캐싱되어 있다면 접속 오류가 나겠죠?
그래서 DNS 설정에는 **TTL**이라는 유효 기간이 있습니다.

* "이 정보는 300초 동안만 유효해. 그 이후엔 다시 물어봐!"라고 명시하는 것이죠.
* **개발자 팁:** 서버 이전 시에는 TTL 값을 미리 낮춰두어야 사용자들이 바뀐 IP로 빠르게 갈아탈 수 있습니다.

---

> "DNS는 인터넷의 유연성을 담당하는 **추상화 계층**이다. 덕분에 사용자는 복잡한 서버 인프라의 변화를 몰라도 이름 하나로 어디든 연결될 수 있다."

---
